import React, { useState, useRef, useEffect, useCallback } from 'react';
import { useAudio } from './AudioContext';
import { FaPlay, FaPause, FaRandom, FaRedo, FaMusic, FaDownload } from 'react-icons/fa';
import { ErrorCategory, handleError } from '../utils/ErrorUtils';
import { useToast } from '../contexts/ToastContext';
import { playSilently } from '../utils/AudioUtils';

// Environment variables for Supabase access
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

// Interface for the track objects used by the playlist component
interface Track {
  media_id: number; // from scene_media.media_id
  name: string;     // from scene_media.media_name
  file: string;     // from scene_media.media_url
  loop?: boolean;    // from scene_media.loop
  volume?: number;   // from scene_media.volume_setting
  scene_id: number; // from scene_media.scene_id
}

const AudioPlaylist: React.FC = () => {
  const { globalVolume, autoplayTriggered, setAutoplayTriggered, isPlaying, setIsPlaying, trackToPlay } = useAudio();
  const { showToast, showError } = useToast();
  const [tracks, setTracks] = useState<Track[]>([]);
  const [currentTrackIndex, setCurrentTrackIndex] = useState<number | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [shuffleMode, setShuffleMode] = useState<boolean>(true); // Default to shuffle mode
  const [loopTrack, setLoopTrack] = useState<boolean>(false); // Track looping state
  const [loopedTrackId, setLoopedTrackId] = useState<number | null>(null); // Track ID to loop
  const autoplayedRef = useRef(false); // Ref to track if autoplay has occurred
  const audioRef = useRef<HTMLAudioElement>(null);

  const forceDownload = async (url: string, baseFilename: string) => {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Network response was not ok: ${response.statusText}`);
      }
      const blob = await response.blob();
      const objectUrl = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = objectUrl;
      // Ensure .mp3 extension for the downloaded file
      const filename = baseFilename.endsWith('.mp3') ? baseFilename : `${baseFilename}.mp3`;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(objectUrl);
    } catch (error) {
      // Use our generic error messaging system instead of console.error
      handleError(error, ErrorCategory.NETWORK, 'FETCH_ERROR');
      showError(ErrorCategory.NETWORK, 'FETCH_ERROR');
    }
  };

  const cueTrack = useCallback((idx: number) => {
    if (!audioRef.current || idx < 0 || idx >= tracks.length) return;
    // Remove console.log to prevent freezing
    audioRef.current.src = tracks[idx].file;
    const trackSpecificVolume = tracks[idx].volume !== undefined ? tracks[idx].volume : 1.0;
    audioRef.current.volume = trackSpecificVolume * globalVolume;
    setCurrentTrackIndex(idx);
  }, [tracks, globalVolume, setCurrentTrackIndex]);

  // Function to play a track
  const playTrack = useCallback((idx: number, forceLoop: boolean = false) => {
    if (idx < 0 || idx >= tracks.length || !audioRef.current) return;
    
    cueTrack(idx); // Cue the track first

    // Handle looping based on track settings or forced loop
    const shouldLoop = forceLoop || (loopTrack && loopedTrackId === tracks[idx].media_id);
    audioRef.current.loop = shouldLoop;
    
    // Play the track but silently handle autoplay errors
    audioRef.current.play().catch(e => {
      // Silently handle the error without showing to the user
      // This is especially important for autoplay errors
      console.debug('Audio playback error (suppressed from UI):', e);
      
      // Only log the error but do not show it to the user
      handleError(e, ErrorCategory.UNKNOWN, 'GENERAL_ERROR');
      
      // Note: We deliberately do NOT call showError() here to avoid displaying autoplay errors
    });
    setIsPlaying(true); // Update the global playing state
  }, [cueTrack, tracks, loopTrack, loopedTrackId, setIsPlaying, showError]);

  useEffect(() => {
    const fetchAudioTracks = async () => {
      setIsLoading(true);
      setError(null);
      
      try {        
        // Make a direct fetch request to the Supabase REST API
        const response = await fetch(`${SUPABASE_URL}/rest/v1/scene_media?media_type=eq.audio&order=scene_id`, {
          headers: {
            'apikey': SUPABASE_ANON_KEY,
            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          throw new Error(`API request failed with status ${response.status}`);
        }
        
        const data = await response.json();
        
        // Transform API response into our Track interface
        const fetchedTracks: Track[] = data.map((item: any) => ({
          media_id: item.media_id,
          name: item.media_name,
          file: item.media_url,
          loop: item.loop || false,
          volume: item.volume_setting || 1.0, // Default volume of 1 if not specified
          scene_id: item.scene_id
        }));
        
        setTracks(fetchedTracks);
        setIsLoading(false);
      } catch (err) {
        // Use our generic error handling system instead of console.error
        handleError(err, ErrorCategory.DATA, 'FETCH_ERROR');
        showError(ErrorCategory.DATA, 'FETCH_ERROR');
        setError('Failed to fetch audio tracks');
        setIsLoading(false);
      }
    };
    
    fetchAudioTracks();
  }, [showError]);

  // Effect for autoplaying a random track on initial load
  useEffect(() => {
    if (!isLoading && tracks.length > 0 && !autoplayedRef.current && !autoplayTriggered) { // Ensure this doesn't run if triggered by button
      const randomIndex = Math.floor(Math.random() * tracks.length);
      playTrack(randomIndex);
      autoplayedRef.current = true; // Mark initial autoplay as done
    }
  }, [isLoading, tracks, playTrack, autoplayTriggered]); // Added autoplayTriggered to dependency array

  // Effect for handling the "Play All" button trigger from AudioContext
  useEffect(() => {
    if (autoplayTriggered && !isLoading && tracks.length > 0) {
      // When Play All button is clicked, always use shuffle mode to pick a random track
      const randomIndex = Math.floor(Math.random() * tracks.length);
      playTrack(randomIndex, false); // Play a random track without forcing loop
      setShuffleMode(true); // Enable shuffle mode when Play All is clicked
      autoplayedRef.current = true; // Mark that autoplay has occurred (either initial or via button)
      // Reset the trigger in context so future button presses still work
      setAutoplayTriggered(false);
      // Ensure isPlaying state is true when we start playing
      setIsPlaying(true);
    }
  }, [autoplayTriggered, isLoading, tracks, playTrack, setAutoplayTriggered, setIsPlaying]);

  // Effect to play a specific track when trackToPlay from context changes
  useEffect(() => {
    if (trackToPlay && trackToPlay.url && tracks.length > 0) {
      const trackIndex = tracks.findIndex(track => track.file === trackToPlay.url);
      if (trackIndex !== -1) {
        // Optionally, turn off shuffle and loop when a specific track is requested
        setShuffleMode(false);
        if (loopedTrackId) {
          setLoopTrack(false);
          setLoopedTrackId(null);
        }
        playTrack(trackIndex, false); // Play the found track, don't force loop
      } else {
        // Use our generic error handling system instead of console.error
        handleError(new Error(`Track URL ${trackToPlay.url} not found in playlist.`), ErrorCategory.UNKNOWN, 'TRACK_NOT_FOUND');
        showError(ErrorCategory.UNKNOWN, 'TRACK_NOT_FOUND');
      }
    }
  }, [trackToPlay, tracks, playTrack, loopedTrackId]); // Dependencies

  // Get a random track index different from the current one
  const getRandomTrackIndex = useCallback(() => {
    if (tracks.length <= 1) return 0;
    let newIndex;
    do {
      newIndex = Math.floor(Math.random() * tracks.length);
    } while (newIndex === currentTrackIndex && tracks.length > 1);
    return newIndex;
  }, [tracks, currentTrackIndex]);

  const handleEnded = () => {
    if (tracks.length === 0) {
      setCurrentTrackIndex(null);
      setIsPlaying(false); // Ensure global state reflects no playback
      return;
    }

    let nextIndex: number | null = null;

    if (shuffleMode) {
      nextIndex = getRandomTrackIndex();
    } else if (currentTrackIndex !== null) {
      if (currentTrackIndex < tracks.length - 1) {
        nextIndex = currentTrackIndex + 1;
      } else {
        nextIndex = 0; // Loop back to the beginning
      }
    }

    if (nextIndex === null) { // Should not happen if tracks.length > 0 but as a safeguard
        setCurrentTrackIndex(null);
        setIsPlaying(false);
        return;
    }

    if (isPlaying) { // If global state is still "playing" (e.g., user hasn't paused)
      playTrack(nextIndex);
    } else { // Global state is "paused"
      cueTrack(nextIndex);
      // Set loop status for the cued track
      if (audioRef.current && nextIndex >= 0 && nextIndex < tracks.length) {
        const trackToCue = tracks[nextIndex];
        audioRef.current.loop = loopTrack && loopedTrackId === trackToCue.media_id;
      }
    }
  };

  // Effect to update volume if globalVolume changes
  useEffect(() => {
    if (audioRef.current && currentTrackIndex !== null) {
      const trackSpecificVolume = tracks[currentTrackIndex].volume !== undefined ? tracks[currentTrackIndex].volume : 1.0;
      audioRef.current.volume = trackSpecificVolume * globalVolume;
    }
  }, [globalVolume, currentTrackIndex, tracks]);

  // Effect to handle global play/pause state changes
  useEffect(() => {
    if (audioRef.current) {
      if (currentTrackIndex === null && !audioRef.current.paused) { // Safety: if no track is cued but audio is playing, pause it.
        audioRef.current.pause();
      } else if (currentTrackIndex !== null && tracks.length > 0 && currentTrackIndex < tracks.length) { // Ensure currentTrackIndex is valid
        if (isPlaying && audioRef.current.paused) {
          playSilently(audioRef.current);
        } else if (!isPlaying && !audioRef.current.paused) {
          audioRef.current.pause();
        }
      }
    }
  }, [isPlaying, currentTrackIndex, tracks]);

  if (isLoading) {
    return (
      <section className="bg-black min-h-[calc(100vh-4rem)] w-full flex flex-col items-center justify-center snap-start">
        <p className="text-fuchsia-300">Loading audio playlist...</p>
      </section>
    );
  }

  if (error) {
    return (
      <section className="bg-black min-h-[calc(100vh-4rem)] w-full flex flex-col items-center justify-center snap-start">
        <p className="text-red-500">Error: {error}</p>
      </section>
    );
  }

  if (tracks.length === 0) {
    return (
      <section className="bg-black min-h-[calc(100vh-4rem)] w-full flex flex-col items-center justify-center snap-start">
        <p className="text-fuchsia-300/80">No distinct audio tracks found in the library.</p>
      </section>
    );
  }

  return (
    <section className="bg-black min-h-[calc(100vh-4rem)] w-full flex flex-col items-center justify-center snap-start p-4 md:p-8">
      <h2 className="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-fuchsia-500 to-pink-500 mb-6 md:mb-8 text-center">
        Soundscapes of Zeal
      </h2>
      <div className="w-full max-w-lg bg-neutral-900/70 border border-fuchsia-700/50 shadow-xl shadow-fuchsia-500/20 rounded-lg p-4 md:p-6">
        {/* Shuffle button at the top */}
        <div className="flex justify-between items-center mb-4 pb-2 border-b border-fuchsia-600/30">
          <div className="text-fuchsia-300 font-medium">
            <FaMusic className="inline mr-2" /> {tracks.length} Tracks Available
          </div>
          <button
            className={`flex items-center gap-2 px-4 py-2 rounded-md transition-colors ${
              shuffleMode 
                ? 'bg-fuchsia-600/80 text-white' 
                : 'bg-neutral-800 text-fuchsia-300 hover:bg-fuchsia-800/40'
            }`}
            onClick={() => {
              setShuffleMode(!shuffleMode);
              // If we have tracks and we're enabling shuffle mode, immediately play a random track
              if (!shuffleMode && tracks.length > 0) {
                playTrack(getRandomTrackIndex());
              }
            }}
            title={shuffleMode ? "Shuffle mode enabled" : "Enable shuffle mode"}
          >
            <FaRandom size={14} />
            <span className="text-sm">Shuffle</span>
          </button>
        </div>
        
        <ul className="space-y-3 max-h-[60vh] overflow-y-auto scrollbar-thin scrollbar-thumb-fuchsia-600 scrollbar-track-neutral-800 pr-2">
          {tracks.map((track, idx) => (
            <li 
              key={track.media_id}
              className={`p-3 md:p-4 rounded-md transition-all duration-200 ease-in-out 
                          ${currentTrackIndex === idx 
                            ? 'bg-gradient-to-r from-fuchsia-600 to-pink-600 text-white shadow-lg'
                            : 'bg-neutral-800 hover:bg-fuchsia-800/40 text-fuchsia-100 hover:text-white'}`}
            >
              <div className="flex justify-between items-center">
                <span className="font-medium text-sm md:text-base flex-grow cursor-pointer" onClick={() => playTrack(idx)}>{track.name}</span>
                <div className="flex items-center gap-2">
                  {/* Play button */}
                  <button 
                    className={`p-1.5 rounded-full transition-colors ${
                      currentTrackIndex === idx && audioRef.current && !audioRef.current.paused 
                        ? 'bg-green-600/20 text-green-400 animate-pulse' 
                        : 'hover:bg-fuchsia-700/30 text-fuchsia-300 hover:text-white'
                    }`}
                    onClick={(e) => {
                      e.stopPropagation();
                      // Turn off shuffle mode when explicitly selecting a track
                      setShuffleMode(false);
                      
                      // Keep the loop state for this track, but don't force looping for other tracks
                      const shouldLoop = loopedTrackId === track.media_id;
                      playTrack(idx, shouldLoop);
                    }}
                    title="Play track"
                  >
                    <FaPlay size={12} />
                  </button>
                  
                  {/* Loop button */}
                  <button 
                    className={`p-1.5 rounded-full transition-colors ${
                      loopedTrackId === track.media_id 
                        ? 'bg-fuchsia-600/80 text-white' 
                        : 'hover:bg-fuchsia-700/30 text-fuchsia-300 hover:text-white'
                    }`}
                    onClick={(e) => {
                      e.stopPropagation();
                      // Turn off shuffle mode when enabling loop
                      setShuffleMode(false);
                      
                      // If this track is already looped, unloop it
                      if (loopedTrackId === track.media_id) {
                        setLoopTrack(false);
                        setLoopedTrackId(null);
                        if (currentTrackIndex === idx && audioRef.current) {
                          audioRef.current.loop = false;
                        }
                      } else {
                        // Clear any existing loop on other tracks first
                        setLoopTrack(true);
                        setLoopedTrackId(track.media_id);
                        
                        // Update the current playing track if it's this one
                        if (currentTrackIndex === idx && audioRef.current) {
                          audioRef.current.loop = true;
                        }
                        // If we're not currently playing this track, start playing it
                        else if (currentTrackIndex !== idx) {
                          playTrack(idx, true);
                        }
                      }
                    }}
                    title={loopedTrackId === track.media_id ? "Disable loop" : "Loop this track"}
                  >
                    <FaRedo size={12} />
                  </button>

                  {/* Download button */}
                  <a
                    href="#"
                    className="p-1.5 rounded-full hover:bg-fuchsia-700/30 text-fuchsia-300 hover:text-white transition-colors"
                    onClick={async (e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      await forceDownload(track.file, track.name);
                      showToast(`Downloading ${track.name}...`, 'info');
                    }}
                    title="Download track"
                  >
                    <FaDownload size={12} />
                  </a>
                </div>
              </div>
            </li>
          ))}
        </ul>
        <audio 
          ref={audioRef} 
          onEnded={handleEnded} 
          className="mt-4 w-full hidden" // Hide default controls, control via UI
          controls={false} 
        />
        {currentTrackIndex !== null && tracks[currentTrackIndex] && (
          <div className="mt-4 p-3 bg-neutral-800/80 rounded-md text-center border border-fuchsia-700/30">
            <div className="flex justify-between items-center">
              <div className="text-left">
                <p className="text-fuchsia-200 text-sm md:text-base font-semibold">
                  Now Playing: <span className="text-pink-300">{tracks[currentTrackIndex].name}</span>
                </p>
                <p className="text-xs text-fuchsia-300/70">Scene ID: {tracks[currentTrackIndex].scene_id}</p>
              </div>
              <button
                className="p-2 rounded-full bg-fuchsia-600/80 text-white hover:bg-fuchsia-700 transition-colors"
                onClick={() => {
                  if (audioRef.current) {
                    if (audioRef.current.paused) {
                      playSilently(audioRef.current);
                    } else {
                      audioRef.current.pause();
                    }
                  }
                }}
                title={audioRef.current?.paused ? "Play" : "Pause"}
            >
              {audioRef.current?.paused ? <FaPlay size={14} /> : <FaPause size={14} />}
            </button>
              >
                {audioRef.current?.paused ? <FaPlay size={14} /> : <FaPause size={14} />}
              </button>
            </div>
          </div>
        )}
      </div>
    </section>
  );
};

export default AudioPlaylist;
